package edu.ucsd.cse232b.jsidrach.xpath;

import edu.ucsd.cse232b.jsidrach.xpath.parser.XPathBaseVisitor;
import edu.ucsd.cse232b.jsidrach.xpath.parser.XPathParser;
import org.w3c.dom.Node;

import java.util.LinkedList;
import java.util.List;

/**
 * XPathVisitor - Visitor for the context tree generated by ANTLR4
 * <p>
 * The traversal of the context tree has to be done manually, recursively calling visit(ctx)<br>
 * Initially, the root of the grammar is invoked<br>
 * Each method modifies the current list of nodes (nl) and returns it<br>
 * </p>
 */
public class XPathVisitor extends XPathBaseVisitor<List<Node>> {

    /**
     * Current list of nodes
     */
    private List<Node> nl;

    /**
     * Public constructor - Initializes the current list of nodes to an empty linked list
     */
    public XPathVisitor() {
        this.nl = new LinkedList<>();
    }

    /**
     * Absolute path (all)
     * <pre>
     * [doc(FileName)/rp]
     *   → [rp](root(FileName))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitApAll(XPathParser.ApAllContext ctx) {
        return null;
    }

    /**
     * Absolute path (children)
     * <pre>
     * [doc(FileName)//rp]
     *   → [.//rp](root(FileName))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitApChildren(XPathParser.ApChildrenContext ctx) {
        return null;
    }

    /**
     * Relative path (tag)
     * <pre>
     * [Identifier](n)
     *   → { c | c ← [∗](n) if tag(c) = Identifier }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpTag(XPathParser.RpTagContext ctx) {
        return null;
    }

    /**
     * Relative path (wildcard)
     * <pre>
     * [∗](n)
     *   → children(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpWildcard(XPathParser.RpWildcardContext ctx) {
        return null;
    }

    /**
     * Relative path (current)
     * <pre>
     * [.](n)
     *   → { n }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpCurrent(XPathParser.RpCurrentContext ctx) {
        return null;
    }

    /**
     * Relative path (parent)
     * <pre>
     * [..](n)
     *   → parent(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpParent(XPathParser.RpParentContext ctx) {
        return null;
    }

    /**
     * Relative path (text)
     * <pre>
     * [text()](n)
     *   → txt(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpText(XPathParser.RpTextContext ctx) {
        return null;
    }

    /**
     * Relative path (attribute)
     * <pre>
     * [@Identifier](n)
     *   → attrib(n, Identifier)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpAttribute(XPathParser.RpAttributeContext ctx) {
        return null;
    }

    /**
     * Relative path (parentheses)
     * <pre>
     * [(rp)](n)
     *   → [rp](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpParentheses(XPathParser.RpParenthesesContext ctx) {
        return null;
    }

    /**
     * Relative path (children)
     * <pre>
     * [rp1/rp2](n)
     *   → unique({ y | x ← [rp1](n), y ← [rp2](x) })
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpChildren(XPathParser.RpChildrenContext ctx) {
        return null;
    }

    /**
     * Relative path (all)
     * <pre>
     * [rp1//rp2](n)
     *   → unique([rp1/rp2](n), [rp1/∗//rp2](n))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpAll(XPathParser.RpAllContext ctx) {
        return null;
    }

    /**
     * Relative path (filter)
     * <pre>
     * [rp[f]](n)
     *   → { x | x ← [rp](n) if [f](x) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpFilter(XPathParser.RpFilterContext ctx) {
        return null;
    }

    /**
     * Relative path (pair)
     * <pre>
     * [rp1, rp2](n)
     *   → [rp1](n), [rp2](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitRpPair(XPathParser.RpPairContext ctx) {
        return null;
    }

    /**
     * Filter (relative path)
     * <pre>
     * [rp](n)
     *   → [rp](n) ≠ { }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFRelativePath(XPathParser.FRelativePathContext ctx) {
        return null;
    }

    /**
     * Filter (value equality)
     * <pre>
     * [rp1 = rp2](n)
     * [rp1 eq rp2](n)
     *   → ∃ x ∈ [rp1](n) ∃ y ∈ [rp2](n) / x eq y
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFValueEquality(XPathParser.FValueEqualityContext ctx) {
        return null;
    }

    /**
     * Filter (identity equality)
     * <pre>
     * [rp1 == rp2](n)
     * [rp1 is rp2](n)
     *   → ∃ x ∈ [rp1](n) ∃ y ∈ [rp2](n) / x is y
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFIdentityEquality(XPathParser.FIdentityEqualityContext ctx) {
        return null;
    }

    /**
     * Filter (parentheses)
     * <pre>
     * [(f)](n)
     *   → [f](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFParentheses(XPathParser.FParenthesesContext ctx) {
        return null;
    }

    /**
     * Filter (and)
     * <pre>
     * [f1 and f2](n)
     *   → [f1](n) ∧ [f2](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFAnd(XPathParser.FAndContext ctx) {
        return null;
    }

    /**
     * Filter (or)
     * <pre>
     * [f1 or f2](n)
     *   → [f1](n) ∨ [f2](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFOr(XPathParser.FOrContext ctx) {
        return null;
    }

    /**
     * Filter (not)
     * <pre>
     * [not f](n)
     *   → ¬[f](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFNot(XPathParser.FNotContext ctx) {
        return null;
    }
}
