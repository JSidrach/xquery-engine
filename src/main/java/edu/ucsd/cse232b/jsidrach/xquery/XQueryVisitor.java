package edu.ucsd.cse232b.jsidrach.xquery;

import edu.ucsd.cse232b.jsidrach.antlr.XQueryParser;
import org.w3c.dom.Node;

import java.util.HashMap;
import java.util.LinkedList;

/**
 * XQueryVisitor - Visitor for the context tree generated by ANTLR4
 * <p>
 * The traversal of the context tree has to be done manually, recursively calling visit(ctx)<br>
 * Initially, the root of the grammar is invoked<br>
 * Each method modifies the current list of nodes (nodes) and returns it<br>
 * </p>
 */
public class XQueryVisitor extends edu.ucsd.cse232b.jsidrach.antlr.XQueryBaseVisitor<LinkedList<Node>> {

    /**
     * Current map of variables
     */
    private HashMap<String, LinkedList<Node>> vars;

    /**
     * Current list of nodes
     */
    private LinkedList<Node> nodes;

    /**
     * XQuery Evaluator
     */
    private XQueryEvaluator xQueryEvaluator;

    /**
     * Public constructor - Initializes the variables
     */
    public XQueryVisitor() throws Exception {
        this.vars = new HashMap<>();
        this.xQueryEvaluator = new XQueryEvaluator();
        this.nodes = new LinkedList<>();
    }

    /*
     * XQuery - Root Rules
     */

    /**
     * XQuery (variable)
     * <pre>
     * [Var(C)]
     *   → { C(Var) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing the value of the variable if it is present in the current context (C)
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitXqVariable(XQueryParser.XqVariableContext ctx) {
        LinkedList<Node> var = vars.get(ctx.Variable().getText());
        if (var == null) {
            var = new LinkedList<>();
        }
        this.nodes = var;
        return this.nodes;
    }

    /**
     * XQuery (constant)
     * <pre>
     * [StringConstant](C)
     *   → { makeText(StringConstant) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing a new text node with the constant string as its content
     */
    @Override
    public LinkedList<Node> visitXqConstant(XQueryParser.XqConstantContext ctx) {
        String quotedText = ctx.StringConstant().getText();
        String text = quotedText.substring(1, quotedText.length() - 1);
        this.nodes = xQueryEvaluator.singleton(xQueryEvaluator.makeText(text));
        return this.nodes;
    }

    /**
     * XQuery (absolute path)
     * <pre>
     * [ap](C)
     *   → [ap]
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the absolute path
     */
    @Override
    public LinkedList<Node> visitXqAbsolutePath(XQueryParser.XqAbsolutePathContext ctx) {
        return visit(ctx.ap());
    }

    /**
     * XQuery (parentheses)
     * <pre>
     * [(xq)](C)
     *   → [xq](C)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the xquery query inside the parentheses
     */
    @Override
    public LinkedList<Node> visitXqParentheses(XQueryParser.XqParenthesesContext ctx) {
        return visit(ctx.xq());
    }

    /**
     * XQuery (pair)
     * <pre>
     * [xq_1, xq_2](C)
     *   → [xq_1](C), [xq_2](C)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes resulting of the union of the lists of nodes produced by both xquery queries
     */
    @Override
    public LinkedList<Node> visitXqPair(XQueryParser.XqPairContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        LinkedList<Node> original = this.nodes;
        nodes.addAll(visit(ctx.xq(0)));
        this.nodes = original;
        nodes.addAll(visit(ctx.xq(1)));
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XQuery (children)
     * <pre>
     * [xq/rp](C)
     *   → unique({ m | n ← [xq](C), m ← [rp](n) })
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of distinct nodes obtained by the xquery query concatenated with the relative path
     */
    @Override
    public LinkedList<Node> visitXqChildren(XQueryParser.XqChildrenContext ctx) {
        visit(ctx.xq());
        this.nodes = XQueryEvaluator.unique(visit(ctx.rp()));
        return this.nodes;
    }

    /**
     * XQuery (all)
     * <pre>
     * [xq//rp](C)
     *   → unique({ m | n ← [xq](C), m ← [.//rp](n) })
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of distinct nodes obtained by the xquery query concatenated with the relative path,
     * union the list of nodes obtained by the xquery query concatenated with the relative path,
     * skipping any number of descendants
     */
    @Override
    public LinkedList<Node> visitXqAll(XQueryParser.XqAllContext ctx) {
        this.nodes = XQueryEvaluator.descendantsOrSelves(visit(ctx.xq()));
        this.nodes = XQueryEvaluator.unique(visit(ctx.rp()));
        return this.nodes;
    }

    /**
     * XQuery (tag)
     * <pre>
     * [&lt;tagName&gt;{ xq }&lt;/tagName&gt;](C)
     *   → { makeElem(tagName, [xq](C)) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing an element with tag tagName and the results of the xquery query as its content
     */
    @Override
    public LinkedList<Node> visitXqTag(XQueryParser.XqTagContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        String tagName = ctx.Identifier(0).getText();
        if (tagName.equals(ctx.Identifier(1).getText())) {
            nodes.add(xQueryEvaluator.makeElem(tagName, visit(ctx.xq())));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XQuery (join)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the join
     */
    @Override
    public LinkedList<Node> visitXqJoin(XQueryParser.XqJoinContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery (let)
     * <pre>
     * [let Var_1 := xq_1, ..., Var_n = xq_n xq_n+1](C)
     *   → [xq_n+1](C_n)
     *   where C_0 := C, C_i := { Var_i → [xq_i](C_i-1) } ∪ C_i-1, i ∈ [1, ..., n]
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the xquery query applied
     * to the context generated by chaining the variable definitions
     */
    @Override
    public LinkedList<Node> visitXqLet(XQueryParser.XqLetContext ctx) {
        HashMap<String, LinkedList<Node>> vars = new HashMap<>(this.vars);
        visit(ctx.letClause());
        visit(ctx.xq());
        this.vars = vars;
        return this.nodes;
    }

    /**
     * XQuery (for let while return - FLWR)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the FLWR expression
     */
    @Override
    public LinkedList<Node> visitXqFLWR(XQueryParser.XqFLWRContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        HashMap<String, LinkedList<Node>> vars = new HashMap<>(this.vars);
        iterateFLWR(ctx, 0, nodes);
        this.vars = vars;
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * Iterates over a FLWR expression, storing the result in the parameter nodes
     *
     * @param ctx    Current parse tree context
     * @param varNum Number of the variable of the forClause the function is currently iterating over
     * @param nodes  Accumulative list of nodes returned by the return clause
     */
    private void iterateFLWR(XQueryParser.XqFLWRContext ctx, int varNum, LinkedList<Node> nodes) {
        // Iteration over for clause finished
        // One node selected for each variable
        if (varNum == ctx.letClause().Variable().size()) {
            HashMap<String, LinkedList<Node>> vars = new HashMap<>(this.vars);
            if (ctx.letClause() != null) {
                visit(ctx.letClause());
            }
            // Add return nodes if the where clause evaluates to true
            if ((ctx.whereClause() == null) || (!visit(ctx.whereClause()).isEmpty())) {
                nodes.addAll(visit(ctx.returnClause()));
            }
            this.vars = vars;
        }
        // Still iterating through for clause variables
        // Select one node for each variable
        else {
            String varName = ctx.forClause().Variable(varNum).getText();
            LinkedList<Node> var = visit(ctx.forClause().xq(varNum));
            for (Node n : var) {
                vars.put(varName, xQueryEvaluator.singleton(n));
                iterateFLWR(ctx, varNum + 1, nodes);
            }
        }
    }

    /*
     * XQuery - For Let Where Return (FLWR)
     */

    /**
     * XQuery - FLWR (for)
     * <pre>
     * [let Var_1 in xq_1, ..., Var_n in xq_n](C)
     * This rule should not be explicitly visited
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return null
     */
    @Override
    public LinkedList<Node> visitForClause(XQueryParser.ForClauseContext ctx) {
        // Return null to raise an exception if caller tries to use the result of visiting the for clause
        return null;
    }

    /**
     * XQuery - FLWR (let)
     * <pre>
     * [let Var_1 := xq_1, ..., Var_n := xq_n](C)
     *   → C_n
     *   where C_0 := C, C_i := { Var_i → [xq_i](C_i-1) } ∪ C_i-1, i ∈ [1, ..., n]
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return null
     */
    @Override
    public LinkedList<Node> visitLetClause(XQueryParser.LetClauseContext ctx) {
        int numVars = ctx.Variable().size();
        for (int i = 0; i < numVars; ++i) {
            String varName = ctx.Variable(i).getText();
            HashMap<String, LinkedList<Node>> previousVars = new HashMap<>(this.vars);
            LinkedList<Node> xquery = visit(ctx.xq(i));
            this.vars = previousVars;
            this.vars.put(varName, xquery);
        }
        // Return null to raise an exception if caller tries to use the result of visiting the let clause
        return null;
    }

    /**
     * XQuery - FLWR (where)
     * <pre>
     * [where Cond](C)
     *   → [Cond](C)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Condition function applied to the current context
     */
    @Override
    public LinkedList<Node> visitWhereClause(XQueryParser.WhereClauseContext ctx) {
        return visit(ctx.cond());
    }

    /**
     * XQuery - FLWR (return)
     * <pre>
     * [return xq](C)
     *   → [xq](C)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the xquery query
     */
    @Override
    public LinkedList<Node> visitReturnClause(XQueryParser.ReturnClauseContext ctx) {
        return visit(ctx.xq());
    }

    /*
     * XQuery - Condition
     */

    /**
     * XQuery - Condition (value equality)
     * <pre>
     * [xq_1 = xq_2](C)
     * [xq_1 eq xq_2](C)
     *   → ∃ x ∈ [xq_1](C) ∃ y ∈ [xq_2](C) / x eq y
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if there exists some x in the first xquery query
     * and some y in the second xquery query that are equal
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitCondValueEquality(XQueryParser.CondValueEqualityContext ctx) {
        LinkedList<Node> nodes = this.nodes;
        LinkedList<Node> l = visit(ctx.xq(0));
        this.nodes = nodes;
        LinkedList<Node> r = visit(ctx.xq(1));
        this.nodes = nodes;
        for (Node nl : l) {
            for (Node nr : r) {
                if (nl.isEqualNode(nr)) {
                    return this.nodes;
                }
            }
        }
        return new LinkedList<>();
    }

    /**
     * XQuery - Condition (identity equality)
     * <pre>
     * [xq_1 == xq_2](C)
     * [xq_1 is xq_2](C)
     *   → ∃ x ∈ [xq_1](C) ∃ y ∈ [xq_2](C) / x is y
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if there exists some x in the first xquery query
     * and some y in the second xquery query that reference the same node
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitCondIdentityEquality(XQueryParser.CondIdentityEqualityContext ctx) {
        LinkedList<Node> nodes = this.nodes;
        LinkedList<Node> l = visit(ctx.xq(0));
        this.nodes = nodes;
        LinkedList<Node> r = visit(ctx.xq(1));
        this.nodes = nodes;
        for (Node nl : l) {
            for (Node nr : r) {
                if (nl.isSameNode(nr)) {
                    return this.nodes;
                }
            }
        }
        return new LinkedList<>();
    }

    /**
     * XQuery - Condition (empty)
     * <pre>
     * [empty(xq)](C)
     *   → [xq](C) = { }
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if the xquery query evaluates to an empty list
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitCondEmpty(XQueryParser.CondEmptyContext ctx) {
        LinkedList<Node> nodes = this.nodes;
        LinkedList<Node> xquery = visit(ctx.xq());
        this.nodes = nodes;
        if (xquery.isEmpty()) {
            return this.nodes;
        }
        return new LinkedList<>();
    }

    /**
     * XQuery - Condition (some)
     * <pre>
     * [some Var_1 in xq_1, ..., Var_n in xq_n satisfies Cond](C)
     *   → ∃ v_1 ∈ [xq_1](C_0) ...  ∃ v_n ∈ [xq_n](C_n-1) / [Cond](C_n)
     *   where C_0 := C, C_i := { Var_i → v_i } ∪ C_i-1, i ∈ [1, ..., n]
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return Condition function applied to the context generated by chaining the variable definitions
     */
    @Override
    public LinkedList<Node> visitCondSome(XQueryParser.CondSomeContext ctx) {
        HashMap<String, LinkedList<Node>> vars = new HashMap<>(this.vars);
        LinkedList<Node> nodes = this.nodes;
        int numVars = ctx.Variable().size();
        for (int i = 0; i < numVars; ++i) {
            String varName = ctx.Variable(i).getText();
            HashMap<String, LinkedList<Node>> previousVars = new HashMap<>(this.vars);
            LinkedList<Node> xquery = visit(ctx.xq(i));
            this.vars = previousVars;
            this.vars.put(varName, xquery);
        }
        LinkedList<Node> cond = visit(ctx.cond());
        this.vars = vars;
        this.nodes = nodes;
        return cond;
    }

    /**
     * XQuery - Condition (parentheses)
     * <pre>
     * [(Cond)](C)
     *   → [Cond](C)
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the condition inside the parentheses
     */
    @Override
    public LinkedList<Node> visitCondParentheses(XQueryParser.CondParenthesesContext ctx) {
        return visit(ctx.cond());
    }

    /**
     * XQuery - Condition (and)
     * <pre>
     * [Cond_1 and Cond_2](C)
     *   → [Cond_1](C) ∧ [Cond_2](C)
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if both of the conditions evaluate to true
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitCondAnd(XQueryParser.CondAndContext ctx) {
        if ((visit(ctx.cond(0)).isEmpty()) || (visit(ctx.cond(1)).isEmpty())) {
            return new LinkedList<>();
        }
        return this.nodes;
    }

    /**
     * XQuery - Condition (or)
     * <pre>
     * [Cond_1 or Cond_2](C)
     *   → [Cond_1](C) ∨ [Cond_2](C)
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if any of the conditions evaluates to true
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitCondOr(XQueryParser.CondOrContext ctx) {
        if ((visit(ctx.cond(0)).isEmpty()) && (visit(ctx.cond(1)).isEmpty())) {
            return new LinkedList<>();
        }
        return this.nodes;
    }

    /**
     * XQuery - Condition (not)
     * <pre>
     * [not Cond](C)
     *   → ¬[Cond](C)
     * </pre>
     * Note: condition functions should keep intact variables and current nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if the condition evaluates to false
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitCondNot(XQueryParser.CondNotContext ctx) {
        if (visit(ctx.cond()).isEmpty()) {
            return this.nodes;
        }
        return new LinkedList<>();
    }

    /*
     * XPath - Absolute Path
     */

    /**
     * XPath - Absolute path (children)
     * <pre>
     * [doc(FileName)/rp]
     *   → [rp](root(FileName))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes resulting of the traversal of the relative path starting from the root of the document
     */
    @Override
    public LinkedList<Node> visitApChildren(XQueryParser.ApChildrenContext ctx) {
        visit(ctx.doc());
        this.nodes = XQueryEvaluator.unique(visit(ctx.rp()));
        return this.nodes;
    }

    /**
     * XPath - Absolute path (all)
     * <pre>
     * [doc(FileName)//rp]
     *   → [.//rp](root(FileName))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes resulting of the traversal of the relative path starting at any node in the document
     */
    @Override
    public LinkedList<Node> visitApAll(XQueryParser.ApAllContext ctx) {
        this.nodes = XQueryEvaluator.descendantsOrSelves(visit(ctx.doc()));
        this.nodes = XQueryEvaluator.unique(visit(ctx.rp()));
        return this.nodes;
    }

    /**
     * XPath - Absolute path (doc)
     * <pre>
     * [doc(FileName)]
     *   → root(FileName)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing the root element of the XML document
     */
    @Override
    public LinkedList<Node> visitApDoc(XQueryParser.ApDocContext ctx) {
        this.nodes = XQueryEvaluator.root(ctx.StringConstant().getText());
        return this.nodes;
    }

    /*
     * XPath - Relative Path
     */

    /**
     * XPath - Relative path (tag)
     * <pre>
     * [Identifier](n)
     *   → { c | c ← [∗](n) if tag(c) = Identifier }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of children nodes that have the given identifier
     */
    @Override
    public LinkedList<Node> visitRpTag(XQueryParser.RpTagContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        String tag = ctx.Identifier().getText();
        for (Node n : this.nodes) {
            LinkedList<Node> children = XQueryEvaluator.children(n);
            for (Node c : children) {
                if (XQueryEvaluator.tag(c).equals(tag)) {
                    nodes.add(c);
                }
            }
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (wildcard)
     * <pre>
     * [∗](n)
     *   → children(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of children nodes
     */
    @Override
    public LinkedList<Node> visitRpWildcard(XQueryParser.RpWildcardContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.children(n));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (current)
     * <pre>
     * [.](n)
     *   → { n }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes
     */
    @Override
    public LinkedList<Node> visitRpCurrent(XQueryParser.RpCurrentContext ctx) {
        return this.nodes;
    }

    /**
     * XPath - Relative path (parent)
     * <pre>
     * [..](n)
     *   → parent(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of parent nodes
     */
    @Override
    public LinkedList<Node> visitRpParent(XQueryParser.RpParentContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.parent(n));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (text)
     * <pre>
     * [text()](n)
     *   → txt(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of text nodes
     */
    @Override
    public LinkedList<Node> visitRpText(XQueryParser.RpTextContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.txt(n));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (attribute)
     * <pre>
     * [@Identifier](n)
     *   → attrib(n, Identifier)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of attribute nodes that have the given attribute name
     */
    @Override
    public LinkedList<Node> visitRpAttribute(XQueryParser.RpAttributeContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        String attId = ctx.Identifier().getText();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.attrib(n, attId));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (parentheses)
     * <pre>
     * [(rp)](n)
     *   → [rp](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the relative path inside the parentheses
     */
    @Override
    public LinkedList<Node> visitRpParentheses(XQueryParser.RpParenthesesContext ctx) {
        return visit(ctx.rp());
    }

    /**
     * XPath - Relative path (children)
     * <pre>
     * [rp_1/rp_2](n)
     *   → unique({ y | x ← [rp_1](n), y ← [rp_2](x) })
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of distinct nodes obtained by the first relative path concatenated with the second relative path
     */
    @Override
    public LinkedList<Node> visitRpChildren(XQueryParser.RpChildrenContext ctx) {
        visit(ctx.rp(0));
        this.nodes = XQueryEvaluator.unique(visit(ctx.rp(1)));
        return this.nodes;
    }

    /**
     * XPath - Relative path (all)
     * <pre>
     * [rp_1//rp_2](n)
     *   → unique([rp_1/rp_2](n), [rp_1/∗//rp_2](n))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of distinct nodes obtained by the first relative path concatenated with the second relative path,
     * union the list of nodes obtained by the first relative path concatenated with the second relative path,
     * skipping any number of descendants
     */
    @Override
    public LinkedList<Node> visitRpAll(XQueryParser.RpAllContext ctx) {
        this.nodes = XQueryEvaluator.descendantsOrSelves(visit(ctx.rp(0)));
        this.nodes = XQueryEvaluator.unique(visit(ctx.rp(1)));
        return this.nodes;
    }

    /**
     * XPath - Relative path (filter)
     * <pre>
     * [rp[f]](n)
     *   → { x | x ← [rp](n) if [f](x) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes by preserving only the relative paths that satisfy the filter
     */
    @Override
    public LinkedList<Node> visitRpFilter(XQueryParser.RpFilterContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        LinkedList<Node> rp = visit(ctx.rp());
        for (Node n : rp) {
            this.nodes = xQueryEvaluator.singleton(n);
            if (!visit(ctx.f()).isEmpty()) {
                nodes.add(n);
            }

        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (pair)
     * <pre>
     * [rp_1, rp_2](n)
     *   → [rp_1](n), [rp_2](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes resulting of the union of the lists of nodes produced by both relative paths
     */
    @Override
    public LinkedList<Node> visitRpPair(XQueryParser.RpPairContext ctx) {
        LinkedList<Node> nodes = new LinkedList<>();
        LinkedList<Node> original = this.nodes;
        nodes.addAll(visit(ctx.rp(0)));
        this.nodes = original;
        nodes.addAll(visit(ctx.rp(1)));
        this.nodes = nodes;
        return this.nodes;
    }

    /*
     * XPath - Filter
     */

    /**
     * XPath - Filter (relative path)
     * <pre>
     * [rp](n)
     *   → [rp](n) ≠ { }
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if the relative path is not empty
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitFRelativePath(XQueryParser.FRelativePathContext ctx) {
        LinkedList<Node> nodes = this.nodes;
        LinkedList<Node> filter = visit(ctx.rp());
        this.nodes = nodes;
        return filter;
    }

    /**
     * XPath - Filter (value equality)
     * <pre>
     * [rp_1 = rp_2](n)
     * [rp_1 eq rp_2](n)
     *   → ∃ x ∈ [rp_1](n) ∃ y ∈ [rp_2](n) / x eq y
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if there exists some x in the first relative path
     * and some y in the second relative path that are equal
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitFValueEquality(XQueryParser.FValueEqualityContext ctx) {
        LinkedList<Node> nodes = this.nodes;
        LinkedList<Node> l = visit(ctx.rp(0));
        this.nodes = nodes;
        LinkedList<Node> r = visit(ctx.rp(1));
        this.nodes = nodes;
        for (Node nl : l) {
            for (Node nr : r) {
                if (nl.isEqualNode(nr)) {
                    return this.nodes;
                }
            }
        }
        return new LinkedList<>();
    }

    /**
     * XPath - Filter (identity equality)
     * <pre>
     * [rp_1 == rp_2](n)
     * [rp_1 is rp_2](n)
     *   → ∃ x ∈ [rp_1](n) ∃ y ∈ [rp_2](n) / x is y
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if there exists some x in the first relative path
     * and some y in the second relative path that reference the same node
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitFIdentityEquality(XQueryParser.FIdentityEqualityContext ctx) {
        LinkedList<Node> nodes = this.nodes;
        LinkedList<Node> l = visit(ctx.rp(0));
        this.nodes = nodes;
        LinkedList<Node> r = visit(ctx.rp(1));
        this.nodes = nodes;
        for (Node nl : l) {
            for (Node nr : r) {
                if (nl.isSameNode(nr)) {
                    return this.nodes;
                }
            }
        }
        return new LinkedList<>();
    }

    /**
     * XPath - Filter (parentheses)
     * <pre>
     * [(f)](n)
     *   → [f](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the filter inside the parentheses
     */
    @Override
    public LinkedList<Node> visitFParentheses(XQueryParser.FParenthesesContext ctx) {
        return visit(ctx.f());
    }

    /**
     * XPath - Filter (and)
     * <pre>
     * [f_1 and f_2](n)
     *   → [f_1](n) ∧ [f_2](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if both of the filters evaluate to true
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitFAnd(XQueryParser.FAndContext ctx) {
        if ((visit(ctx.f(0)).isEmpty()) || (visit(ctx.f(1)).isEmpty())) {
            return new LinkedList<>();
        }
        return this.nodes;
    }

    /**
     * XPath - Filter (or)
     * <pre>
     * [f_1 or f_2](n)
     *   → [f_1](n) ∨ [f_2](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if any of the filters evaluates to true
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitFOr(XQueryParser.FOrContext ctx) {
        if ((visit(ctx.f(0)).isEmpty()) && (visit(ctx.f(1)).isEmpty())) {
            return new LinkedList<>();
        }
        return this.nodes;
    }

    /**
     * XPath - Filter (not)
     * <pre>
     * [not f](n)
     *   → ¬[f](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if the filter evaluates to false
     * - an empty list otherwise
     */
    @Override
    public LinkedList<Node> visitFNot(XQueryParser.FNotContext ctx) {
        if (visit(ctx.f()).isEmpty()) {
            return this.nodes;
        }
        return new LinkedList<>();
    }
}
