package edu.ucsd.cse232b.jsidrach.xquery;

import edu.ucsd.cse232b.jsidrach.antlr.XQueryParser;
import org.w3c.dom.Node;

import java.util.*;

/**
 * XQueryVisitor - Visitor for the context tree generated by ANTLR4
 * <p>
 * The traversal of the context tree has to be done manually, recursively calling visit(ctx)<br>
 * Initially, the root of the grammar is invoked<br>
 * Each method modifies the current list of nodes (nodes) and returns it<br>
 * </p>
 */
public class XQueryVisitor extends edu.ucsd.cse232b.jsidrach.antlr.XQueryBaseVisitor<List<Node>> {

    /**
     * Current map of variables
     */
    private Map<String, List<Node>> vars;

    /**
     * Variables context stack
     */
    private Stack<Map<String, List<Node>>> varsContext;

    /**
     * Current list of nodes
     */
    private List<Node> nodes;

    /**
     * XQuery Evaluator
     */
    private XQueryEvaluator xQueryEvaluator;

    /**
     * Public constructor - Initializes the variables
     */
    public XQueryVisitor() throws Exception {
        this.vars = new HashMap<>();
        this.varsContext = new Stack<>();
        this.xQueryEvaluator = new XQueryEvaluator();
        this.nodes = new LinkedList<>();
    }

    /*
     * XQuery - Root Rules
     */

    /**
     * XQuery (variable)
     * <pre>
     * [Var(C)]
     *   → { C(Var) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing the value of the variable if it is present in the current context (C)
     * - an empty list otherwise
     */
    @Override
    public List<Node> visitXqVariable(XQueryParser.XqVariableContext ctx) {
        List<Node> var = vars.get(ctx.Variable().getText());
        if (var == null) {
            return new LinkedList<>();
        }
        return var;
    }

    /**
     * XQuery (constant)
     * <pre>
     * [StringConstant](C)
     *   → { makeText(StringConstant) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing a new text node with the constant string as its content
     */
    @Override
    public List<Node> visitXqConstant(XQueryParser.XqConstantContext ctx) {
        String quotedText = ctx.StringConstant().getText();
        String text = quotedText.substring(1, quotedText.length() - 1);
        List<Node> nodes = new LinkedList<>();
        nodes.add(xQueryEvaluator.makeText(text));
        return nodes;
    }

    /**
     * XQuery (absolute path)
     * <pre>
     * [ap](C)
     *   → [ap]
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the absolute path
     */
    @Override
    public List<Node> visitXqAbsolutePath(XQueryParser.XqAbsolutePathContext ctx) {
        return visit(ctx.ap());
    }


    /**
     * XQuery (parentheses)
     * <pre>
     * [(xq)](C)
     *   → [xq](C)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the xquery query inside the parentheses
     */
    @Override
    public List<Node> visitXqParentheses(XQueryParser.XqParenthesesContext ctx) {
        return visit(ctx.xq());
    }

    /**
     * XQuery (pair)
     * <pre>
     * [xq1, xq2](C)
     *   → [xq1](C), [xq2](C)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitXqPair(XQueryParser.XqPairContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery (children)
     * <pre>
     * [xq/rp](C)
     *   → unique({ m | n ← [xq](C), m ← [rp](n) })
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitXqChildren(XQueryParser.XqChildrenContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery (all)
     * <pre>
     * [xq//rp](C)
     *   → unique({ m | n ← [xq](C), m ← [.//rp](n) })
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitXqAll(XQueryParser.XqAllContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery (tag)
     * <pre>
     * [&lt;tagName&gt;{ xq }&lt;/tagName&gt;](C)
     *   → { makeElem(tagName, [xq](C)) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing an element with tag tagName and the results of the xquery query as its content
     */
    @Override
    public List<Node> visitXqTag(XQueryParser.XqTagContext ctx) {
        List<Node> nodes = new LinkedList<>();
        String tagName = ctx.Identifier(0).getText();
        if (!tagName.equals(ctx.Identifier(1).getText())) {
            return nodes;
        }
        nodes.add(xQueryEvaluator.makeElem(tagName, visit(ctx.xq())));
        return nodes;
    }

    /**
     * XQuery (for let while return - FLWR)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitXqFLWR(XQueryParser.XqFLWRContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery (let)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitXqLet(XQueryParser.XqLetContext ctx) {
        // TODO
        return null;
    }

    /*
     * XQuery - For Let Where Return (FLWR)
     */

    /**
     * XQuery - FLWR (for)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitFor(XQueryParser.ForContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - FLWR (let)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitLet(XQueryParser.LetContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - FLWR (where)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitWhere(XQueryParser.WhereContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - FLWR (return)
     * <pre>
     * TODO
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitReturn(XQueryParser.ReturnContext ctx) {
        // TODO
        return null;
    }

    /*
     * XQuery - Condition
     */

    /**
     * XQuery - Condition (value equality)
     * <pre>
     * [xq1 = xq2](C)
     * [xq1 eq xq2](C)
     *   → ∃ x ∈ [xq1](C) ∃ y ∈ [xq2](C) / x eq y
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitCondValueEquality(XQueryParser.CondValueEqualityContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - Condition (identity equality)
     * <pre>
     * [xq1 == xq2](C)
     * [xq1 is xq2](C)
     *   → ∃ x ∈ [xq1](C) ∃ y ∈ [xq2](C) / x is y
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitCondIdentityEquality(XQueryParser.CondIdentityEqualityContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - Condition (empty)
     * <pre>
     * [empty(xq)](C)
     *   → [xq](C) = { }
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitCondEmpty(XQueryParser.CondEmptyContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - Condition (some)
     * <pre>
     * [some Var_1 in xq_1, ..., Var_n in xq_n satisfies Cond](C)
     *   → ∃ v_1 ∈ [xq_1](C_0) ...  ∃ v_n ∈ [xq_n](C_n-1) / [Cond](C_n)
     * where C_0 := C, C_i := { Var_i → v_i } ∪ C_i-1, i ∈ [1, ..., n]
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitCondSome(XQueryParser.CondSomeContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - Condition (parentheses)
     * <pre>
     * [(Cond)](C)
     *   → [Cond](C)
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the condition inside the parentheses
     */
    @Override
    public List<Node> visitCondParentheses(XQueryParser.CondParenthesesContext ctx) {
        return visit(ctx.cond());
    }

    /**
     * XQuery - Condition (and)
     * <pre>
     * [Cond1 and Cond2](C)
     *   → [Cond1](C) ∧ [Cond2](C)
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitCondAnd(XQueryParser.CondAndContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - Condition (or)
     * <pre>
     * [Cond1 or Cond2](C)
     *   → [Cond1](C) ∨ [Cond2](C)
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitCondOr(XQueryParser.CondOrContext ctx) {
        // TODO
        return null;
    }

    /**
     * XQuery - Condition (not)
     * <pre>
     * [not Cond](C)
     *   → ¬[Cond](C)
     * </pre>
     * Note: condition functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return TODO
     */
    @Override
    public List<Node> visitCondNot(XQueryParser.CondNotContext ctx) {
        // TODO
        return null;
    }

    /*
     * XPath - Absolute Path
     */

    /**
     * XPath - Absolute path (children)
     * <pre>
     * [doc(FileName)/rp]
     *   → [rp](root(FileName))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes resulting of the traversal of the relative path starting from the root of the document
     */
    @Override
    public List<Node> visitApChildren(XQueryParser.ApChildrenContext ctx) {
        visit(ctx.doc());
        visit(ctx.rp());
        this.nodes = XQueryEvaluator.unique(this.nodes);
        return this.nodes;
    }

    /**
     * XPath - Absolute path (all)
     * <pre>
     * [doc(FileName)//rp]
     *   → [.//rp](root(FileName))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes resulting of the traversal of the relative path starting at any node in the document
     */
    @Override
    public List<Node> visitApAll(XQueryParser.ApAllContext ctx) {
        visit(ctx.doc());
        this.nodes = XQueryEvaluator.descendantsOrSelves(this.nodes);
        visit(ctx.rp());
        this.nodes = XQueryEvaluator.unique(this.nodes);
        return this.nodes;
    }

    /**
     * XPath - Absolute path (doc)
     * <pre>
     * [doc(FileName)]
     *   → root(FileName)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Singleton list containing the root element of the XML document
     */
    @Override
    public List<Node> visitApDoc(XQueryParser.ApDocContext ctx) {
        this.nodes = XQueryEvaluator.root(ctx.StringConstant().getText());
        return this.nodes;
    }

    /*
     * XPath - Relative Path
     */

    /**
     * XPath - Relative path (tag)
     * <pre>
     * [Identifier](n)
     *   → { c | c ← [∗](n) if tag(c) = Identifier }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of children nodes that have the given identifier
     */
    @Override
    public List<Node> visitRpTag(XQueryParser.RpTagContext ctx) {
        List<Node> nodes = new LinkedList<>();
        String tag = ctx.Identifier().getText();
        for (Node n : this.nodes) {
            List<Node> children = XQueryEvaluator.children(n);
            for (Node c : children) {
                if (XQueryEvaluator.tag(c).equals(tag)) {
                    nodes.add(c);
                }
            }
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (wildcard)
     * <pre>
     * [∗](n)
     *   → children(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of children nodes
     */
    @Override
    public List<Node> visitRpWildcard(XQueryParser.RpWildcardContext ctx) {
        List<Node> nodes = new LinkedList<>();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.children(n));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (current)
     * <pre>
     * [.](n)
     *   → { n }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes
     */
    @Override
    public List<Node> visitRpCurrent(XQueryParser.RpCurrentContext ctx) {
        return this.nodes;
    }

    /**
     * XPath - Relative path (parent)
     * <pre>
     * [..](n)
     *   → parent(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of parent nodes
     */
    @Override
    public List<Node> visitRpParent(XQueryParser.RpParentContext ctx) {
        List<Node> nodes = new LinkedList<>();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.parent(n));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (text)
     * <pre>
     * [text()](n)
     *   → txt(n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of text nodes
     */
    @Override
    public List<Node> visitRpText(XQueryParser.RpTextContext ctx) {
        List<Node> nodes = new LinkedList<>();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.txt(n));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (attribute)
     * <pre>
     * [@Identifier](n)
     *   → attrib(n, Identifier)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of attribute nodes that have the given attribute name
     */
    @Override
    public List<Node> visitRpAttribute(XQueryParser.RpAttributeContext ctx) {
        List<Node> nodes = new LinkedList<>();
        String attId = ctx.Identifier().getText();
        for (Node n : this.nodes) {
            nodes.addAll(XQueryEvaluator.attrib(n, attId));
        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (parentheses)
     * <pre>
     * [(rp)](n)
     *   → [rp](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the relative path inside the parentheses
     */
    @Override
    public List<Node> visitRpParentheses(XQueryParser.RpParenthesesContext ctx) {
        return visit(ctx.rp());
    }

    /**
     * XPath - Relative path (children)
     * <pre>
     * [rp1/rp2](n)
     *   → unique({ y | x ← [rp1](n), y ← [rp2](x) })
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of distinct nodes obtained by the first relative path concatenated with the second relative path
     */
    @Override
    public List<Node> visitRpChildren(XQueryParser.RpChildrenContext ctx) {
        List<Node> nodes = new LinkedList<>();
        List<Node> children = visit(ctx.rp(0));
        for (Node c : children) {
            this.nodes = new LinkedList<>();
            this.nodes.add(c);
            nodes.addAll(visit(ctx.rp(1)));
        }
        this.nodes = XQueryEvaluator.unique(nodes);
        return this.nodes;
    }

    /**
     * XPath - Relative path (all)
     * <pre>
     * [rp1//rp2](n)
     *   → unique([rp1/rp2](n), [rp1/∗//rp2](n))
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of distinct nodes obtained by the first relative path concatenated with the second relative path,
     * union the list of nodes obtained by the first relative path concatenated with the second relative path,
     * skipping any number of descendants
     */
    @Override
    public List<Node> visitRpAll(XQueryParser.RpAllContext ctx) {
        visit(ctx.rp(0));
        this.nodes = XQueryEvaluator.descendantsOrSelves(this.nodes);
        visit(ctx.rp(1));
        this.nodes = XQueryEvaluator.unique(this.nodes);
        return this.nodes;
    }

    /**
     * XPath - Relative path (filter)
     * <pre>
     * [rp[f]](n)
     *   → { x | x ← [rp](n) if [f](x) }
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes by preserving only the relative paths that satisfy the filter
     */
    @Override
    public List<Node> visitRpFilter(XQueryParser.RpFilterContext ctx) {
        List<Node> nodes = new LinkedList<>();
        List<Node> rp = visit(ctx.rp());
        for (Node n : rp) {
            this.nodes = new LinkedList<>();
            this.nodes.add(n);
            if (!visit(ctx.f()).isEmpty()) {
                nodes.add(n);
            }

        }
        this.nodes = nodes;
        return this.nodes;
    }

    /**
     * XPath - Relative path (pair)
     * <pre>
     * [rp1, rp2](n)
     *   → [rp1](n), [rp2](n)
     * </pre>
     *
     * @param ctx Current parse tree context
     * @return List of nodes resulting of the union of the lists of nodes produced by both relative paths
     */
    @Override
    public List<Node> visitRpPair(XQueryParser.RpPairContext ctx) {
        List<Node> nodes = new LinkedList<>();
        List<Node> original = this.nodes;
        nodes.addAll(visit(ctx.rp(0)));
        this.nodes = original;
        nodes.addAll(visit(ctx.rp(1)));
        this.nodes = nodes;
        return this.nodes;
    }

    /*
     * XPath - Filter
     */

    /**
     * XPath - Filter (relative path)
     * <pre>
     * [rp](n)
     *   → [rp](n) ≠ { }
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if the relative path is not empty
     * - an empty list otherwise
     */
    @Override
    public List<Node> visitFRelativePath(XQueryParser.FRelativePathContext ctx) {
        List<Node> nodes = this.nodes;
        List<Node> filter = visit(ctx.rp());
        this.nodes = nodes;
        return filter;
    }

    /**
     * XPath - Filter (value equality)
     * <pre>
     * [rp1 = rp2](n)
     * [rp1 eq rp2](n)
     *   → ∃ x ∈ [rp1](n) ∃ y ∈ [rp2](n) / x eq y
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if there exists some x in the first relative path
     * and some y in the second relative path that are equal
     * - an empty list otherwise
     */
    @Override
    public List<Node> visitFValueEquality(XQueryParser.FValueEqualityContext ctx) {
        List<Node> nodes = this.nodes;
        List<Node> l = visit(ctx.rp(0));
        this.nodes = nodes;
        List<Node> r = visit(ctx.rp(1));
        this.nodes = nodes;
        for (Node nl : l) {
            for (Node nr : r) {
                if (nl.isEqualNode(nr)) {
                    return this.nodes;
                }
            }
        }
        return new LinkedList<>();
    }

    /**
     * XPath - Filter (identity equality)
     * <pre>
     * [rp1 == rp2](n)
     * [rp1 is rp2](n)
     *   → ∃ x ∈ [rp1](n) ∃ y ∈ [rp2](n) / x is y
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if there exists some x in the first relative path
     * and some y in the second relative path that reference the same node
     * - an empty list otherwise
     */
    @Override
    public List<Node> visitFIdentityEquality(XQueryParser.FIdentityEqualityContext ctx) {
        List<Node> nodes = this.nodes;
        List<Node> l = visit(ctx.rp(0));
        this.nodes = nodes;
        List<Node> r = visit(ctx.rp(1));
        this.nodes = nodes;
        for (Node nl : l) {
            for (Node nr : r) {
                if (nl.isSameNode(nr)) {
                    return this.nodes;
                }
            }
        }
        return new LinkedList<>();
    }

    /**
     * XPath - Filter (parentheses)
     * <pre>
     * [(f)](n)
     *   → [f](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return List of nodes returned by the filter inside the parentheses
     */
    @Override
    public List<Node> visitFParentheses(XQueryParser.FParenthesesContext ctx) {
        return visit(ctx.f());
    }

    /**
     * XPath - Filter (and)
     * <pre>
     * [f1 and f2](n)
     *   → [f1](n) ∧ [f2](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if both of the filters evaluate to true
     * - an empty list otherwise
     */
    @Override
    public List<Node> visitFAnd(XQueryParser.FAndContext ctx) {
        if ((visit(ctx.f(0)).isEmpty()) || (visit(ctx.f(1)).isEmpty())) {
            return new LinkedList<>();
        }
        return this.nodes;
    }

    /**
     * XPath - Filter (or)
     * <pre>
     * [f1 or f2](n)
     *   → [f1](n) ∨ [f2](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if any of the filters evaluates to true
     * - an empty list otherwise
     */
    @Override
    public List<Node> visitFOr(XQueryParser.FOrContext ctx) {
        if ((visit(ctx.f(0)).isEmpty()) && (visit(ctx.f(1)).isEmpty())) {
            return new LinkedList<>();
        }
        return this.nodes;
    }

    /**
     * XPath - Filter (not)
     * <pre>
     * [not f](n)
     *   → ¬[f](n)
     * </pre>
     * Note: filter functions should not change the current list of nodes
     *
     * @param ctx Current parse tree context
     * @return Current list of nodes if the filter evaluates to false
     * - an empty list otherwise
     */
    @Override
    public List<Node> visitFNot(XQueryParser.FNotContext ctx) {
        if (visit(ctx.f()).isEmpty()) {
            return this.nodes;
        }
        return new LinkedList<>();
    }
}
